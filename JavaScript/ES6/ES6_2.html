<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>

<script>

    //声明一个set
    // let s = new Set()
    //   s.size  个数
    //   s.add  添加
    //  s.delete  删除
    //  s.has 检测元素

    // let arr = [1, 3, 2, 5, 6, 7,]
    //    去重    let ss = [...new Set()]

    //    2.找交集
    /*   let arr2 = [1, 2, 4, 5, 6, 7, 8]
       let resule = [...new Set()].filter(item =>{
           let sss = new Set(arr2);
           return sss.has(item);
       })*/

    /* let arr2 = [1, 2, 4, 6, 7, 8, 10]
     let resule = [...new Set(arr)].filter(item => new Set(arr2).has(item))
     console.log(resule)*/

    //    3.并集
    /* let union = [...new Set([...arr, ...arr2])]
     console.log(union)*/

    //    4.差集
    /*   let diff = [...new Set(arr)].filter(item => !(new Set(arr2).has(item)))
       console.log(diff)*/

    //--------------------------------------------------

    //声明一个Map
    // let m = new Map();
    //添加元素
    /*m.set('name', '你号');
    console.log(m)
    m.set('fang', function () {
        console.log('添加了一个方法！')
    })
    let key = {
        school: '数组'
    };
    m.set(key, ['1', '2'])*/


    //    size
    /*  console.log(m.size)*/

    //    删除
    // m.delete('name')

    //   获取
    // console.log(m.get('fang'));

    //    遍历
    /*  for (let v of m) {
          console.log(v)
      }

      //    清空
      m.clear()*/


    //--------------------------------------------------

    // SE5属性方法继承
    /* function Public(name, age) {
         this.name = name;
         this.age = age
     }

     Public.prototype.undei = function () {
         console.log('公共的方法')
     }

     function CarryOn(name, age, pop, yes) {
         Public.call(this, name, age)
         this.pop = pop;
         this.yes = yes
     }

     CarryOn.prototype = new Public()

     CarryOn.prototype.good = function () {
         console.log('使用的方法')
     }

     let employ = new CarryOn('xhz', '22', '删除', '成功！')

     console.log(employ)
     employ.good()
     employ.undei()*/

    //--------------------------------------------------

    //    ES6
    /*    class Public {
            constructor(brand, price) {
                this.brand = brand
                this.price = price
            }

            worth() {
                console.log('good')
            }
        }

        class SmaatPublic extends Public {
            constructor(brand, price, colo, size) {
                super(brand, price);
                this.colo = colo
                this.size = size
            }

            phot() {
                console.log('子类函数')
            }

        }
        const examination = new SmaatPublic('Phone13', '5999', '蓝色', '14')
        console.log(examination)*/

</script>
<script>

    //对象的几个方法
    //Object.is判断对象是否相等
    // console.log(Object.is(undefined, null))

    //Object.assign   对象的合并
    /* const configood = {
         nameL: '11',
         port: 3306,
         name: 'root',
         pass: 'root',
         yes: '成功！'
     }
     const console = {
         host: 'www.gaoyuzi.cn',
         port: '8899',
         name: 'gaoyuzi',
         pass: 'xuge',
         miss: '失败！'
     }
     //`第一个 和第二个 相同的值才会产生覆盖  否则不会
     console.log(Object.assign(configood, console))*/


    //--------------------------------------------------

    /*    const school = {
            name: "xhz",
            cities: ['上海', '北京'],
            xueke: ['前端', 'Java', 'Python']
        }

        //    获取键值
        console.log(Object.keys(school));
        //获取对象所有值
        console.log(Object.values(school));
        //entries   每个元素都是数组 第一个是键 第二个是值  帮助床架MAP
        // console.log(Object.entries(school));
        const m = new Map(Object.entries(school));
        console.log(m.get('name'));*/
    // console.log(Object.keys(school));

    //--------------------------------------------------

    //   Object.fromEntries 二维数组转换为对象
    /*  const result = Object.fromEntries([
          ['name', '凌晨'],
          ['xueke', 'JAVA']
      ])*/

    //MAP二维数组转换为对象
    /*  const m = new Map();
      m.set('name', 'ATGUIGU')
      const result = Object.fromEntries(m)*/
    // console.log(result)

    //    Object.entries ES8对象转为数组
    /*    const arr  = Object.entries({
            name:'凌晨'
        })
        console.log(arr)*/

    //--------------------------------------------------

    //    数组 flat 平  多维数组转为 一维数组
    /*  const arr = [1, 2, 3, 4, [6, 7]]
      const arr2 = [1, 2, 3, 4, [6, 7, [9, 10]]]
      //    参数为深度 是一个数组
      console.log(arr2.flat(2))*/

    // flastMap
    /*   const arr = [1, 2, 3, 4]
       const result = arr.flatMap(item => [item * 10])
       console.log(result)*/

    //--------------------------------------------------

    //    私有属性
    /*class Person {
        //    公有属性
        name;
        //    私有属性
        #age;
        #weight;
        //    方法
        constructor(name, age, weight) {
            this.name = name;
            this.#age = age;
            this.#weight = weight;
        }
        //    私有属性 可以通过 内部得方法 调用进行打印出来
        init() {
            console.log(this.name)
            console.log(this.#age)
        }
    }

    //    私有属性 在外部是没办法进行 打印出来得
    const girl = new Person('凌晨', 22, '45kg')
    /!* console.log(girl.name) //可以打印出来
     console.log(girl.#age) //不能打印出来*!/
    //    调用内部方法 打印私有属性
    girl.init()*/


    //--------------------------------------------------

    //    promise.allSettled([p1,p2])   // 始终返回成功
    //    promise.all([p1,p2])   都成功 才会成功，如果有一个失败 就返回失败


</script>

</html>
