<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>循环 && switch ||</title>
</head>

<body>
</body>
<script>
    //范围值进行使用if条件
    /* if (true) {
         console.log('输出！')
     }*/

    // 固定值进行 switch 进行循环判断
    /*  switch (true) {
          case true:
              console.log('switch输出！');
      }*/

    // && 与  (两边都需要去进行满足)   || 或  (两边满足一个条件即可)     ! 非
    // 为假的值 : undefined  NaN  0  false  ""  null
    // && 遇到真就往后走,或者走到最后 返回最后一个值
    // 使用if(...&&...){ #只有前面的条件2个都满足 才会走进去执行}

    // || 遇到假就往后走，或者遇到真或者走到最后  返回最后一个值 或者当前遇到真的值
    // 使用if(...||...){ #只有前面的条件2个满足一个 才会走进去执行, 否则不会进行当前体内执行}

    /* let name = '';
       console.log(name || '未找到数据！');*/

    // let a = !a; // a等于false
    // a != b; // a不等于b
    // console.log(a);

</script>
<script>

    //关于i++ 和 ++i 在循环时没有差别, 但是在赋值时会有差别
    // ++在前先自增，++在后先赋值

    // let i = 0;
    /* for (; i < 10;) {
         console.log('for', +i);
         i++
     }*/

    /*  while (i < 5) {
          console.log('whlie' + i);
          i++
      }*/

    /*console.log(typeof (typeof(undefined)))
    console.log(isNaN(null))
    console.log(isNaN(undefined))*/

    // 后续学习 研究 算法
    // 斐波那契数列   黄金分隔数列  兔子数列
    // 显示类型转换
    // 隐士类型转换

</script>
<script>
    /*
    *
    * 耦合
    * 高内聚，低耦合 --> 模块的单一责任制
    * 解耦合
    *
    * */

    <!-- 函数构造器  -->
    /* let goodName = new function () {
        console.log('---构造函数---')
    }*/

    <!-- 声明式函数  -->
    /* function testName(name) {
        return name || '您没有填写姓名';
        console.log('---函数---')
    }*/

    // console.log(testName('姓名'))

    <!--  函数表达式 匿名式函数(字面量)  -->
    /*let testNameTow = function (a, b) {
        console.log(arguments[1])
        console.log(' 函数表达式-----匿名式函数')
    }
    testNameTow(6, 7)*/

    //实参和形参是存放在不同的地方,但是有映射关系，不管你的实参怎么赋值你的形参都会跟着变，前提是你的形参得有一个和实参对应得值
    //每一个函数如果你不返回return  默认最后得语句都会有return,函数会自动增加得。

    //初始化  参数 默认为：undefined
    //ES6 写法
    //谁不是undefined 就找谁, 映射关系！  function case(a=1,b=2) {  console.log(a)//1  console.log(b) //2}   case(undefined, 2)

    // function testName() {
    /*  let a = arguments[0] || 1;
      let b = arguments[1] || 2;*/
    // typeof  打印出来得全是字符串 后面加 ''
    //这里不要去直接哪形参去做判断,应该是实参使用arguments[x]
    // var a = typeof (arguments[0]) !== 'undefined' ? arguments[0] : 1;
    // var b = typeof (arguments[1]) !== 'undefined' ? arguments[1] : 2;
    // console.log(a + b);
    // }

    // testName()

</script>
<script>

    /* 斐波那契数列*/
    //1. n3 = n2 + n1
    //2. n <= 2
    /*  function fb(n) {
          if (n <= 2) {
              return 1
          }
          return fb(n - 1) + fb(n - 2)
          //    n = 5 --> fb(5) = 3 +2  --> fb(4) = 2+1 ....
      }

      console.log(fb(6))*/

    /*
     *
     * 这里打印的 函数字面量
     *
    console.log(a);
    function a(a) {
        var a = 10;
        var a = function () {
        }
    }
    var a = 1;*/

    /* //  暗示全局变量
     var a = 1;
     b = 2;
     console.log(window.b) // window.a  = a; window.b =b;*/

    /*  function test() {
          let a = b = 1;
          console.log(a) //1
      }

      test();
      console.log(window.a) //undefined
      console.log(window.b) //1
     */

    /*
    *先提升变量声，在提升函数
    *
    * 活跃对象，函数上下文
    * AO
    * 1、寻找形参和变量声明
    * 2、实参值赋值给形参
    * 3、找函数声明、赋值
    * 4、执行
    * */
    //GO(全局上下文)
    /*1.找变量
      2.找函数声明
      3.执行*/

    /* function test(a) {
            var  a;
            console.log(a)  // 5
            console.log(aaa); // function aaa() {}
            var a = 1;
            console.log(aaa); // function aaa() {}
            console.log(b) // undefined
            console.log(a) // 1
            function aaa() {
            }  //字面量提升 预编译
            console.log(a)  //1
            var b = function () {
            }//字面量提升 预编译
            console.log(b)  // function () {}
            function d() {
            }
        }
        test(5)*/

    //预编译执行，之后就不再做了，后面的赋值可以修改预编译
    /* function test(a, b) {
         console.log(a);  //1
         c = 0;
         var c;
         a = 5;
         b = 6;
         console.log(b); //6
         function b() {
         } // 已经提前预编译了，但是之后 赋值了 6
         function d() {
         }
         console.log(d) // function d() {}
         console.log(b) // 6
     }

     test(1);*/

    /*  console.log(a, b) //a--> function a(){}  b--> undefined
      function a() {
      }*/

    /*var b = function b() {
    };  //这里没有赋值，所有上面打印不出来 undefined
    console.log(b)*/




</script>
</html>
